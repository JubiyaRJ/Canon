'use strict';

var dive = require('dive'),
	path = require('path'),
	fs = require('fs'),
	urlify = require('urlify').create({
		spaces: '-',
		toLower: true
	});

function Compendium () {

	this.catalog = {};

}

Compendium.prototype.scanDirectories = function (cb) {

	var cwd = this.getDirectory(),
		files = /\.(md|markdown)/,
		breakdown,
		_this = this,
		ref, href;

	dive(cwd, { recursive: true, files: true, directories: true }, function (err, file) {

		if (files.test(path.extname(file))) {

			// breakdown the file into the bits and pieces we need
			breakdown = _this.breakdown(file.replace(new RegExp(cwd + '/?'), ''));

			// create the nested tree structure if it doesn't exist in the catalog
			// and return a reference to the deepest point required
			ref = _this.createProperties(_this.catalog, breakdown.paths);

			// urlify each part of the path, turn it into a string seperated by /
			// and then add a leading slash if none exists
			href = breakdown.paths.map(function (part) {
				return urlify(part);
			}).join('/').replace(/^\/?(.)/, '/$1');

			ref[breakdown.title] = {
				href: href + '/' + urlify(breakdown.file.replace(/\.(md|markdown)/, '')),
				title: breakdown.title,
				markdown: breakdown.markdown,
				bFile: !breakdown.isDir
			};

		}

	}, function (err) {

		// we're done, any post scan processing required?

		if (cb) cb(null, _this.catalog);

	});

}

Compendium.prototype.setDirectory = function (dir) {

	this._directory = this.dir;

}

Compendium.prototype.getDirectory = function () {

	return this._directory = this._directory || process.cwd();

}

Compendium.prototype.createProperties = function (obj, keys) {

	var key,
	ref = obj;

	// clone the keys
	keys = keys.slice(0);

	while(keys.length) {

		key = keys.shift();
		ref[key] = ref[key] || {};
		ref = ref[key];

	}

	return ref;

}

Compendium.prototype.breakdown = function (p) {

	var o = {
		isIndex: false,
		isDir: fs.statSync(p).isDirectory(),
		path: p,
		paths: [],
		title: path.basename(p),
		file: path.basename(p),
		markdown: fs.readFileSync(p, 'utf8')
	};

	if (o.file.replace(/.(md|markdown)/) === 'index') o.isIndex = true;

	// determine the directory structure
	if (/\//g.test(p)) {
		o.paths = path.dirname(p).split(path.sep);
	}

	return o;

}

Compendium.prototype.getCatalog = function (type) {

	type = type || 'json';

	if (type === 'json') return this.catalog;
	if (type === 'html') return this.toHTML();

}

Compendium.prototype.toHTML = function (catalog) {

	catalog = catalog || this.catalog;

	return this.renderTree(catalog, '<ul class=\'navigation\'>');

}

Compendium.prototype.renderTree = function (ref, openingTag) {

	var _this = this,
		openingTag = openingTag || '<ul>',
		str = openingTag;

	Object.keys(ref).forEach(function (el) {

		if (ref[el].bFile !== undefined) {
			str += '<li><a href="' + ref[el].href + '">' + ref[el].title + '</a></li>';
		} else if (typeof ref[el] === 'object') {
			str += '<li>' + el;
			str += _this.renderTree(ref[el]);
			str += '</li>';
		}
	});

	str += '</ul>';

	return str;

}

Compendium.prototype.get = function (href) {

	var page = {},
	href = href || '';

	page = this.traverseTree(this.catalog, 'href', href);

	return page;

}

Compendium.prototype.traverseTree = function (ref, prop, val) {

	var _this = this,
		page;

	Object.keys(ref).forEach(function (el) {

		if (page === undefined) {

			if (ref[el][prop] !== undefined && ref[el][prop] === val) {
				page = ref[el];
			} else if (typeof ref[el] === 'object') {
				page = _this.traverseTree(ref[el], prop, val);
			}

		}

	});

	return page;

};

module.exports = Compendium;